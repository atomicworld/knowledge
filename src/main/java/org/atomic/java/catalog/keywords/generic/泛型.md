#### 泛型了解



	泛型是JDK 1.5的一项新特性，它的本质是参数化类型（Parameterized Type）的应用，也就是说所操作的数据类型被指定为一个参数，在用到的时候在指定具体的类型。

	这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。+



	在程序源码中存在，在编译后的字节码文件中，就已经被替换为原来的原始类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList<int>与ArrayList<String>就是同一个类。

	所以说泛型技术实际上是Java语言的一颗语法糖，Java语言中的**泛型实现方法称为类型擦除**，基于这种方法实现的泛型被称为**伪泛型**。（类型擦除在后面在学习）



一些基本术语，以ArrayList<E>和ArrayList<Integer>做简要介绍：

1. 整个成为ArrayList<E>泛型类型
2. ArrayList<E>中的 E称为类型变量或者类型参数
3. 整个ArrayList<Integer> 称为参数化的类型
4. ArrayList<Integer>中的integer称为类型参数的实例或者实际类型参数
5. ArrayList<Integer>中的<Integer>念为typeof   Integer
6. ArrayList称为原始类型



	使用变量E表示集合的元素类型，K和V分别表示关键字与值的类型。（需要时还可以用临近的字母U和S）表示“任意类型”。



- 泛型的类型参数只能是类类型，不能是简单类型。
- 不能对确切的泛型类型使用instanceof操作。



##### 类型通配符

1、类型通配符一般是使用 ? 代替具体的类型参数。

	例如 **List<?>** 在逻辑上是**List<String>, List<Integer>** 等所有List<具体类型实参>的父类。

	类型通配符一般是使用？代替具体的类型实参

	注意了，

	**此处’？’是类型实参，而不是类型形参 ！**

	**此处’？’是类型实参，而不是类型形参 ！** 

	**此处’？’是类型实参，而不是类型形参 ！**

	再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。

	可以解决当具体类型不确定的时候，这个通配符就是 ?  ；

	当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。



##### 静态方法与泛型

静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；

如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。

即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。



##### 泛型上下边界

	在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：

	类型实参只准传入某种类型的父类或某种类型的子类

	为泛型添加上边界，即传入的类型实参必须是指定类型的子类型



#### Java泛型方法和类型通配符的区别

一、你会发现所有能用类型通配符（?）解决的问题都能用泛型方法解决，并且泛型方法可以解决的更好：

最典型的一个例子就是：

```
a. 类型通配符：void func(List<? extends A> list);

b. 完全可以用泛型方法完美解决：<T extends A> void func(List<T> list);

```

二、要说两者最明显的区别就是：

i.  **?泛型对象是只读的，不可修改，因为?类型是不确定的，可以代表范围内任意类型**

ii.  **而泛型方法中的泛型参数对象是可修改的，因为类型参数T是确定的（在调用方法时确定），因为T可以用范围内任意类型指定**

三、这样好像说的通配符?一无是处，但是并不是这样，Java设计类型通配符?是有道理的，首先一个最明显的优点就是?的书写要比泛型方法简洁，无需先声明类型参数，其次它们有各自的应用场景：

    i. 一般只读就用?，要修改就用泛型方法，例如一个进行修改的典型的泛型方法的例子：
    public <T> void func(List<T> list, T t) {
    	list.add(t); 
    }
    
    ii. 在多个参数、返回值之间存在类型依赖关系就应该使用泛型方法，否则就应该是通配符?：
    	具体讲就是，如果一个方法的返回值、某些参数的类型依赖另一个参数的类型就应该使用泛型方法，因为被依赖的类型如果是不确定的?，那么其他元素就无法依赖它），
    例如：
    	<T> void func(List<? extends T> list, T t);  
    	// 即第一个参数依赖第二个参数的类型（第一个参数list的类型参数必须是第二个参数的类型或者其子类）
    	
        可以看到，Java支持泛型方法和?混用；
    
        这个方法也可以写成：
        <T, E extends T> void func(List<E> list, T t);  
        // 明显意义是一样	的，只不过这个list可以修改，而上一个list无法修改
        
        总之就是 一旦返回值、形参之间存在类型依赖关系就只能使用泛型方法   
        否则就应该使用?

四、对泛型方法的类型参数进行规约：

	即有时候可能不必使用泛型方法的地方，你不小心麻烦地写成了泛型方法，而此时你可以将其规约成使用 ? 的最简形式


    i. 总结地来讲就是一句话：只出现一次 & 对它没有任何依赖
    
    ii. 例如：
    	<T, E extends T> void func(List<T> l1, List<E> l2);  
    	// 这里E只在形参中出现了一次（类型参数声明不算），并且没有任何其他东西（方法形参、返回值）依赖		// 它，那么就可以把E规约成?
    	
    	！！最终规约的结果就是：
    	<T> void func(List<T> l1, List<? extends T> l2);
    	

5) 一个最典型的应用就是容器赋值方法（Java的API）：

    public static <T> void Collections.copy(List<T> dest, List<? extends T> src) {
    	... 
    }
    	// 从src拷贝到dest，那么dest最好是src的类型或者其父类，因为这样才能类型兼容，并且src只是读取，	 // 没必要做修改，因此使用?还可以强制避免你对src做不必要的修改，增加的安全性

