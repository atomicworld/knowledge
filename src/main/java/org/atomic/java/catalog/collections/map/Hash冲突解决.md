###Hash冲突解决

[TOC]

####什么是哈希冲突？

	其实就是再采用哈希函数对输入域进行映射到哈希表的时候，因为哈希表的位桶的数目远小于输入域的关键字的个数；

	所以，对于输入域的关键字来说，很可能会产生这样一种情况，也就是，一个关键字会映射到同一个位桶中的情况，这种情况就就叫做哈希冲突

	解决哈希冲突的有三种方案，一种叫做**拉链法**（也叫作链接法、链地址法，一个意思），另外分别为：**开放地址法**和**再散列法**。



####拉链法

	**HashMap，HashSet其实都是采用的拉链法来解决哈希冲突的**，就是**在每个位桶实现的时候，我们采用链表（jdk1.8之后采用链表+红黑树）的数据结构，来去存取发生哈希冲突的输入域的关键字（也就是被哈希函数映射到同一个位桶上的关键字）**。首先来看使用拉链法解决哈希冲突的几个操作：

	①插入操作：在发生哈希冲突的时候，我们输入域的关键字去映射到位桶（实际上是实现位桶的这个数据结构，链表或者红黑树）中去的时候，我们先检查带插入元素x是否出现在表中，很明显，这个查找所用的次数不会超过加载因子（n/m：n为输入域的关键字个数，m为位桶的数目），它是个常数，所以插入操作的最坏时间复杂度为O(1)的。

	②查询操作：和①一样，在发生哈希冲突的时候，我们去检索的时间复杂度不会超过加载因子，也就是检索数据的时间复杂度也是O(1)的

	③删除操作：如果在拉链法中我们想要使用链表这种数据结构来实现位桶，那么这个链表一定是双向链表，因为在删除一个元素x的时候，需要更改x的前驱元素的next指针的属性，把x从链表中删除。这个操作的时间复杂度也是O(1)的。

**拉链法的优点**：

与开放定址法相比，拉链法有如下几个优点：

①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；

②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；

③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；

④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。

**拉链法的缺点**

	指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。



####开放地址法

	开放地址法有个非常关键的特征，就是所有输入的元素全部存放在哈希表里，也就是说，位桶的实现是不需要任何的链表来实现的，换句话说，也就是这个哈希表的装载因子不会超过1。它的实现是在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。所以这种方法又称为再散列法。

有几种常用的探查序列的方法：

①线性探查

dii=1，2，3，…，m-1；这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

（使用例子：ThreadLocal里面的ThreadLocalMap）

②二次探查

di=12，-12，22，-22，…，k2，-k2    ( k<=m/2 )；这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。

③ 伪随机探测

di=伪随机数序列；具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），生成一个位随机序列，并给定一个随机数做起点，每次去加上这个伪随机数++就可以了



####再散列法

	再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置

	缺点：每次冲突都要重新散列，计算时间增加。

