###深拷贝、浅拷贝

[TOC]

#### 对象拷贝（Object Copy）

	指的是将一个对象的所有属性（成员变量）拷贝到另一个有着相同类类型的对象中去。

	举例说明：比如，对象A和对象B都属于类S，具有属性a和b。那么对对象A进行拷贝操作赋值给对象B就是：B.a=A.a;  B.b=A.b;



#### 浅拷贝（shallow clone）

##### 定义：

	我们这里说的浅拷贝是指我们拷贝出来的对象内部的引用类型变量和原来对象内部引用类型变量是同一引用（指向同一对象）。但是我们拷贝出来的对象和新对象不是同一对象。

	①对于数据类型是**基本数据类型**的成员变量，浅拷贝会直接进行**值传递**，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。

	②对于数据类型是**引用数据类型**的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行**引用传递**，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。

	简单来说，**新（拷贝产生）、旧（元对象）对象不同，但是内部如果有引用类型的变量，新、旧对象引用的都是同一引用，基本数据类型是自己的属性（不同）**



#### 实现：

1. 通过拷贝构造方法实现浅拷贝
2. 通过重写clone()方法进行浅拷贝

```
1. String类型非常特殊，所以我额外设置了一个字符串类型的成员变量来进行说明。
2. 首先，String类型属于引用数据类型，不属于基本数据类型，但是String类型的数据是存放在常量池中的，也就是无法修改的！
3. 也就是说，当我将name属性从"Jack" 改为 "Tom" 后，并不是修改了这个数据的值，而是把这个数据的引用从指向 "Jack" 这个常量，改为了指向 "Tom" 这个常量。
4. 在这种情况下，另一个对象的name属性值仍然指向 "Jack" 不会受到影响。

public Object clone() {
	Object obj = null;
	try {
		//调用Object类的clone方法，返回一个Object实例
		obj = super.clone();
	} catch (CloneNotSupportedException e) {
		e.printStackTrace();
	}
	return obj;
}
```



#### 深拷贝（deep clone）

##### 定义：

	 全部拷贝原对象的内容，包括内存的引用类型也进行拷贝

实现：

1. 通过重写clone方法来实现深拷贝
2. 通过对象序列化实现深拷贝

进行了深拷贝之后，无论是什么类型的属性值的修改，都不会影响另一个对象的属性值。

```
public Object clone() {
	Object obj=null;
    try {
    	obj= super.clone();
    } catch (CloneNotSupportedException e) {
    	e.printStackTrace();
    }
    // TODO 深度复制引用对象
    Kid kid = (Kid) obj;
    kid.height = (Height) stu.getHeight().clone();
    return obj;
}
```



