Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存总分配了不同大小的内存空间

数据类型

1. 基本数据类型：
   1. 数值类型：
      1. 整型（byte,short,int,long）
      2. 浮点型（float,double）
   2. 字符型(char)：
   3. 布尔型(boolean)：
2. 引用数据类型：
   1. 类(class)
   2. 接口（interface）
   3. 数组（[]）

| 类型   | 占用存储空间 | 数值范围          |
| ------ | ------------ | ----------------- |
| byte   | 1 字节       | -128~127          |
| short  | 2 字节       | -2^15^~2^15^-1    |
| int    | 4 字节       | -2^31^-2^31^-1    |
| long   | 8 字节       | -2^63^~2^63^-1    |
|        |              |                   |
| float  | 4 字节       | -2^128^ ~ +2^128^ |
| double | 8 字节       | -2^1024^~2^1024^  |



```
byte b1 = 3, b2 = 4, b;
b = b1 + b2;	//编译错误，整型无法自动降级成 byte
b = 3 + 4;
```



```
byte c = 130;	//超过byte范围
byte b = 130;有没有问题?，（有）。
如果我想让赋值正确，可以怎么做（强制类型转换，截取最低一个字节）? 结果是多少呢?

1. 获取130这个数据的二进制。 00000000 00000000 00000000 10000010 这是130的原码，也是反码，还	是补码。
2. 做截取操作，截成byte类型的了。 10000010 这个结果是补码。 
3. 已知补码求原码： 
	反码： 10000010（补） - 1  = 10000001
	原码： 10000001（反） = 1 11111110 = -126
```



知识点：

 原码：
 	一个正数，转换为二进制位就是这个正数的原码。
 	负数的绝对值转换成二进制位，然后在高位补1，就是这个负数的原码
 反码： 
	正数的反码就是原码
	负数的反码，等于原码除符号位以外所有的位取反
 补码：
 	正数的补码与原码相同
 	负数的补码为，其原码除符号位外所有位取反（得到反码了），然后最低位加1.

```
最后总结一下：
　　正数的反码和补码都与原码相同。
　　负数的反码为对该数的原码除符号位外各位取反。
　　负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1　　

各自的优缺点：
　　原码最好理解了，但是加减法不够方便：
　　	1-1 = (00000001)原 + (10000001)原 = (10000010)原 = (-2) 显然不正确。
　　	
　　反码稍微困难一些，解决了加减法的问题
　　	1-1 = (00000001)反 + (11111110)反 = (11111111)反 = (-0) 有点小问题。
　　	
　　补码理解困难，其他就没什么缺点了
　　	1-1 = (00000001)补 + (11111110)补 = (11111111)补 = (-1) 正确

 反码：解决负数加法运算问题，将减法运算转换为加法运算，从而简化运算规则；
 补码：解决负数加法运算正负零问题，弥补了反码的不足。

反码 = 原码（除符号位外）每位取反
补码 = 反码 + 1
反码 = 补码  - 1
```



关于数据类型强制转换，先后顺序问题

```
System.out.println('a'); 			//ascii
System.out.println('a'+1);			//ascii +1

System.out.println("hello"+'a'+1);	//字符串拼接 
System.out.println('a'+1+"hello");	//98hello

System.out.println("5+5="+5+5);		//字符串拼接
System.out.println(5+5+"=5+5"); 	//10=5+5
```



逻辑运算符：&、&&、|、||

	针对数据类型为boolean

位运算符：<<、>>、>>>、

	&： 按位“与”操作符，如果两个数的二进制，相同位数都是1，则该位结果是1，否则是0.

	|： 按位“或”操作符，如果两个数的二进制，相同位数有一个是1，则该位结果是1，否则是0

	^： 按位“异或”操作符，如果两个数的二进制，相同位数只有一个是1，则该位结果是1，否则是0



	~：按位“非”操作符，属于一元操作符，只对一个操作数进行操作，（其他按位操作符是二元操作符）

		按位“非”生成与输入位相反的值，——若输入0，则输出1，若输入1，则输出0。

1. 计算 m * 2^n^ 次方

	（如计算3X8==3<<3）  

 2. 判断一个数n的奇偶性  

    偶数： a&1 = 0   

    奇数： a&1 = 1 

    n&1==1？“奇数”：“偶数” 

	3. 不用临时变量交换两个数

    a = a^b;  

    b = b^a;  

    a = a^b; 

	4. 取绝对值

    (a^(a>>31))-(a>>31)  

    先整理一下使用位运算取绝对值的思路：

    1. 若a为正数，则不变，需要用异或0保持的特点；

       若a为负数，则其补码为源码翻转每一位后+1，先求其源码，补码-1后再翻转每一位，此时需要使用异或1具有翻转的特点。

       任何正数右移31后只剩符号位0，最终结果为0，任何负数右移31后也只剩符号位1，溢出的31位截断，空出的31位补符号位1，最终结果为-1.

       右移31操作可以取得任何整数的符号位。

       那么综合上面的步骤，可得到公式：

       	a>>31取得a的符号，

       		若a为正数，a>>31等于0，a^0=a，不变；

       		若a为负数，a>>31等于-1 ，a^-1（a^0xFFFFFFFF）翻转每一位. 

5. 取int型变量a的第k位 ( k=0,1,2……sizeof(int) )

   a>>k&1 

6. 将int型变量a的第k位清0

   a=a&~(1<< k）  

7. 将int型变量a的第k位置1

   a=a |（1<< k） 

8. int型变量a循环左移k次，

   a=a << k |a>>16-k 	(设sizeof(int)=16)  

9. int型变量a循环右移k次，

   a=a>> k |a < <16-k	 (设sizeof(int)=16) 

10. 整数的平均值 

    对于两个整数x,y，假设用 (x+y)/2 求平均值。会产生溢出。

    由于 x+y 可能会大于INT_MAX，可是我们知道它们的平均值是肯定不会溢出的。

    ```
    int average(int x, int y) {
    	return (x&y)+((x^y)>>1);  
    } 
    ```

11. 推断一个整数是不是2的幂，对于一个数 x >= 0，推断他是不是2的幂  

    ```
    boolean power2(int x) {  
    	return ((x&(x-1))==0)&&(x!=0)  
    }  
    ```

12. 取模运算转化成位运算 (在不产生溢出的情况下)  

    a % (2^n) 等价于 a & (2^n - 1)  

13. 乘法运算转化成位运算 (在不产生溢出的情况下)  

    a * (2^n) 等价于 a < < n  

14. 除法运算转化成位运算 (在不产生溢出的情况下)  

    a / (2^n) 等价于 a>> n  

    例: 12/8 == 12>>3  

15.a % 2 等价于 

	a & 1  

16. a

    ```
    if (x == a) {  
    	x = b;  
    } else {  
    	x = a;  
    }  
    ```

    等价于 

    ```
    x = a ^ b ^ x;
    ```

17. x 的 相反数 

    (~x+1)